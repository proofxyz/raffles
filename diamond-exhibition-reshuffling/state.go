package main

import (
	"math"
	"math/rand"

	"github.com/ccssmnn/hego"
)

// state is the state of the simulated annealing algorithm.
type state struct {
	initial     allocations // initial allocations (used in the score computation)
	current     allocations // current allocations
	src         rand.Source // random source
	cachedScore float64     // score of the current allocations, cached for performance
}

// newState creates a new state from a list of initial allocations and a random source.
func newState(initial allocations, src rand.Source) *state {
	s := state{
		initial: initial,
		current: initial,
		src:     src,
	}
	s.cachedScore = s.current.score(s.initial)

	return &s
}

// numAllocations returns the number of allocations in the state.
func (s *state) numAllocations() int {
	return len(s.initial)
}

// numTokens returns the number of tokens in the state.
func (s *state) numTokens() int {
	return s.current.numTokens()
}

// score returns the score of the current allocation state.
func (s *state) score() float64 {
	return s.cachedScore
}

// swap swaps two tokens in the current allocation state.
// allocId{A,B} are the indices of the allocations whose tokens are swapped.
func (s *state) swap(allocIdA, tokenIdA, allocIdB, tokenIdB int) {
	s.current[allocIdA] = s.current[allocIdA].copy()
	s.current[allocIdB] = s.current[allocIdB].copy()

	a := s.current[allocIdA]
	b := s.current[allocIdB]

	s.cachedScore -= a.score(s.initial[allocIdA])
	s.cachedScore -= b.score(s.initial[allocIdB])

	a.moveToken(tokenIdA, b)
	b.moveToken(tokenIdB, a)

	s.cachedScore += a.score(s.initial[allocIdA])
	s.cachedScore += b.score(s.initial[allocIdB])
}

// neighbor returns a neighbor of the current state for the simulated annealing process.
// The neighbor is generated by randomly swapping two tokens.
func (s state) neighbor() state {
	rng := rand.New(s.src)

	allocIdA := rng.Intn(s.numAllocations())
	allocIdB := rng.Intn(s.numAllocations())
	for allocIdA == allocIdB {
		// swapping within the same allocation yields the same state.
		// we sample again in this case.
		return s.neighbor()
	}

	tokenIdA := s.current[allocIdA].drawToken(s.src)
	tokenIdB := s.current[allocIdB].drawToken(s.src)
	if tokenIdA == tokenIdB {
		// We can never sample the same token from different allocations.
		panic("Sampling the same token from ")
	}

	current := make(allocations, s.numAllocations())
	copy(current, s.current)

	s2 := s
	s2.current = current
	s2.swap(allocIdA, tokenIdA, allocIdB, tokenIdB)
	return s2
}

// Neighbor returns a neighbor of the current state for the simulated annealing process.
func (s state) Neighbor() hego.AnnealingState {
	return s.neighbor()
}

// Energy returns the energy of the current state for the simulated annealing process.
func (s state) Energy() float64 {
	return -float64(s.cachedScore)
}

// anneal runs the simulated annealing algorithm on the state.
func (s state) anneal(annealingFactor float64, verbose bool) (*state, *hego.SAResult, error) {
	settings := hego.SASettings{
		Temperature:     10,
		AnnealingFactor: annealingFactor,
	}

	// iterations until we reach temp = 1 (which is the minimum energy difference
	// between two neighboring states that are not equivalent)
	numIterToLukewarm := int(-math.Log(settings.Temperature) / math.Log(float64(settings.AnnealingFactor)))

	settings.Settings.MaxIterations = 2 * numIterToLukewarm
	if verbose {
		settings.Settings.Verbose = settings.Settings.MaxIterations / 20
	}

	result, err := hego.SA(s, settings)
	if err != nil {
		return nil, nil, err
	}

	finalState := result.State.(state)
	return &finalState, &result, nil
}
